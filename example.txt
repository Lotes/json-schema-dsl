#constants (of any defined type)
const BLOCK_SIZE: integer = 5  
const LIST: UnboundedIntBlock = [1,2,3]
const PERSON: Person = {
	name: "Tom",
	age: 12
}

#annotation
#Annotations add information to the schema structure generated by the schema parser.
annotation Description(text: string)

enum FormatType {
	TEXT_PASSWORD,
	TEXT_SINGLE_LINE,
	TEXT_MULTI_LINE,
	NUMBER_SPIN,
	NUMBER_SLIDER
}
annotaion Format(dataType: FormatType, param: integer = 0)

#any (keyword)
@Description("Example description")
typedef AnyDictionary = dictionary of integer => any
#produces objects like {"1": 1, "2": true, "-3": 1.4, "4": "blubb", "5": {}, "6": []}

#booleans
typedef RenamedBoolean = boolean

#integers
@Format(FormatType.NUMBER_SPIN)
typedef NonPositiveInteger = integer[..0] #..-3, -2, -1, 0
typedef NonNegativeInteger = integer[0..] #0, 1, 2, 3, ..
typedef PositiveInteger = integer(0..] #1,2,3, .. #mind the round parethesis!
typedef NegativeInteger = integer[..0) #..-3, -2, -1

#floats
typedef PositiveFloat = number(0..] # 0.2, 3.14, 88.0 ..

#strings
@Description("Identifiers are used to name properties.")
typedef Identifier = string /^[a-zA-Z_][a-zA-Z_0-9]*$/  #"abc123", "_1Aa", "lutscher"
enum Orientation {
	HORIZONTAL, #"HORIZONTAL"
	VERTICAL    #"VERTICAL"
}
enum Direction {
	NORTH,
	EAST,
	SOUTH,
	WEST
}

#arrays
typedef FixedIntBlock = array[BLOCK_SIZE] of integer   #[1,2,3,4,5]  
typedef VarIntBlock = array[2..BLOCK_SIZE] of integer  #[1,2], [1,2,3,4], ...
typedef MinIntBlock = array[BLOCK_SIZE..] of integer   #[1,2,3,4,5,6], [1,2,3,4,5,6,7,8,9]
typedef UnboundedIntBlock = array of integer           #[], [1], [1,2], ... any size
typedef EvenSizedIntBlock = array[2,4,6,8] of integer  #[1,2], [1,2,3,4], ...

#dictionaries
typedef UnboundedIntConstants = dictionary of Identifier => integer  #{abc: 1, def: 2}
typedef VarIntConstants = dictionary[2..10] of Identifier => integer #just 2 entries
typedef FixedIntConstants = dictionary[5] of Identifier => integer   #exactly 5 entries
typedef MaxIntConstants = dictionary[..5] of Identifier => integer   #at most 5 entries

#unions
union NullableString { #null, "", "abc", "abcdef"
	null,              #a type for "null" => keyword
	string
}


union Bullshit { #"WEST", 0, 1, -2, {"xyz": 456}
	Direction,
	integer,
	UnboundedIntConstants
}

#alls
all Zero { #just 0
	NonPositiveInteger,
	NonNegativeInteger
}

#structs
struct Person {
	name: string  
	age: NonNegativeInteger
}

struct Employee: Person { #important: no polymorphism. An array of Person can not contain Employees?
	personnelNumber: integer
	department: string
}

struct Student: Person {
	matriculationNumber: integer
	studyCourse: string
}

struct Tutor: Employee, Student {
	tutorCourse: string
}

#switch
enum MessageType {
	AAA,
	BBB
}

struct Message {
	type: MessageType
	switch type {
		case AAA:
			message: integer
		case BBB:
			message: boolean
	}
}

struct Example {
	id: integer
	switch(id) {
		case [1..10):      #range, actual range 0..9
		case 11:           #single value
		case [-20,-10,12]: #list of values
		default:           #else case
	}
}

#if-then-else
struct ContainsExample {
	list: UnboundedIntBlock
	if(2 in list) {        #tests if list contains element
	
	} else {
	
	}
}

#strict structs
strict struct StrictExample { #strict = other properties than the defined one are not allowed
	name: string
	size: integer
	checked: boolean
}

#optional properties
struct Node {
	content: integer
	left: Node?
	right: Node?
}
#Type? === NullableType with union NullableType { null, Type }


###
more expressions for if-then-else? 
==, !=, <, <=, >, >=, &&, ||, in 
###