#ASSUMPTIONS/RULES

null == undefined

#constants (of any defined type)
const BLOCK_SIZE: integer = 5  
const LIST: UnboundedIntBlock = [1,2,3]
const PERSON: Person = {
	name: "Tom",
	age: 12
}

#annotation
#Annotations add information to the schema structure generated by the schema parser.
annotation Description(text: string)

enum FormatType {
	TEXT_PASSWORD,
	TEXT_SINGLE_LINE,
	TEXT_MULTI_LINE,
	NUMBER_SPIN,
	NUMBER_SLIDER
}
annotaion Format(dataType: FormatType, param: integer = 0)

#any (keyword)
@Description("Example description")
typedef AnyDictionary = dictionary of integer => any
#produces objects like {"0": null, "1": 1, "2": true, "-3": 1.4, "4": "blubb", "5": {}, "6": []}

#not (keyword)
typedef AnyButNotNull = any not null

typedef AnyButNotPrimitive = any not union {
	boolean,
	string,
	integer,
	number
}

typedef A = B not C not D
#problem: (B not C) not D or B not (C not D), I prefer the last one. + optional use of parenthesis in type definition

#booleans
typedef RenamedBoolean = boolean

#integers
@Format(FormatType.NUMBER_SPIN)
typedef NonPositiveInteger = integer[..0] #..-3, -2, -1, 0
typedef NonNegativeInteger = integer[0..] #0, 1, 2, 3, ..
typedef PositiveInteger = integer(0..] #1,2,3, .. #mind the round parethesis!
typedef NegativeInteger = integer[..0) #..-3, -2, -1

#floats
typedef PositiveFloat = number(0..] # 0.2, 3.14, 88.0 ..

#strings
@Description("Identifiers are used to name properties.")
typedef Identifier = string /^[a-zA-Z_][a-zA-Z_0-9]*$/  #"abc123", "_1Aa", "lutscher"
enum Orientation {
	HORIZONTAL, #"HORIZONTAL"
	VERTICAL    #"VERTICAL"
}
enum Direction {
	NORTH,
	EAST,
	SOUTH,
	WEST
}

#arrays
typedef FixedIntBlock = array[BLOCK_SIZE] of integer   #[1,2,3,4,5]  
typedef VarIntBlock = array[2..BLOCK_SIZE] of integer  #[1,2], [1,2,3,4], ...
typedef MinIntBlock = array[BLOCK_SIZE..] of integer   #[1,2,3,4,5,6], [1,2,3,4,5,6,7,8,9]
typedef UnboundedIntBlock = array of integer           #[], [1], [1,2], ... any size
typedef EvenSizedIntBlock = array[2,4,6,8] of integer  #[1,2], [1,2,3,4], ...

#dictionaries
typedef UnboundedIntConstants = dictionary of Identifier => integer  #{abc: 1, def: 2}
typedef VarIntConstants = dictionary[2..10] of Identifier => integer #just 2 entries
typedef FixedIntConstants = dictionary[5] of Identifier => integer   #exactly 5 entries
typedef MaxIntConstants = dictionary[..5] of Identifier => integer   #at most 5 entries

#unions
union NullableString { #null, "", "abc", "abcdef"
	null,              #a type for "null" => keyword
	string
}


union Bullshit { #"WEST", 0, 1, -2, {"xyz": 456}
	Direction,
	integer,
	UnboundedIntConstants
}

#alls
all Zero { #just 0
	NonPositiveInteger,
	NonNegativeInteger
}

#structs
struct Person {
	name: string  
	age: NonNegativeInteger
}

struct Employee: Person { #important: no polymorphism. An array of Person can not contain Employees!
	personnelNumber: integer
	department: string
}

struct Student: Person {
	matriculationNumber: integer
	studyCourse: string
}

struct Tutor: Employee, Student {
	tutorCourse: string
}

#switch
enum MessageType {
	AAA,
	BBB
}

struct Message {
	type: MessageType
	switch type {
		case AAA:
			message: integer
		case BBB:
			message: boolean
	}
}

struct SwitchExample {
	id: integer
	switch(id) {
		case [1..10):                       #range, actual range 0..9
		case 11:                            #single value
		case [-20,-10,12]:                  #list of values
		case [1..10] or 11 or [-20,-10,12]: #one of the top three cases
		case [1..5] and 3 and [3,2,1]:      #all of the top three cases
		case 1 or 2 and 3                   #1 or (2 and 3)
		default:                            #else case
	}
}

#array switch
struct ArraySwitchExample {
	list: array of integer
	array_switch(list) {              #find a better keyword than "array_switch"
		case 1:                       #list contains 1
		case [2..4):                  #list contains 2 and 3
		case [7,-8,9]:                #list contains 7, -8, 9
		case 1 or [2..4) or [7,-8,9]: #list contains one of the top three cases
		case 1 and [1..4) and [1,2]:  #list contains all of the top three cases
		case 1 or 2 and 3             #list contains 1 or (2 and 3)
		default:                      #else case
	}
}

#strict structs
strict struct StrictExample { #strict = other properties than the defined one are not allowed
	name: string
	size: integer
	checked: boolean
}

#optional properties
struct Node {
	content: integer
	left: optional Node
	right: optional Node
}
#optional Type === NullableType with union NullableType { null, Type }

#inline (unnamed) type definitions
struct Blakeks {
	member1: array[0..10] of union {
		optional string,
		struct { 
			a: integer[-100,100], 
			b: string /blubber/,
			c: enum { A, B, C },
			d: all { Type1, Type2, Type3 }
		}
	}
	member2: strict struct { ... }
}

#DUBIOUS FEATURES

#if-then-else
struct ContainsExample {
	list: UnboundedIntBlock
	if(2 in list) {        #tests if list contains element
	
	} else {
	
	}
}

#more expressions for if-then-else: ==, !=, <, <=, >, >=, &&, ||, in... overkill...
