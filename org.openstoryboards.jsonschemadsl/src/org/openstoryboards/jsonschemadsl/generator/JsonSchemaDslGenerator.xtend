/*
 * generated by Xtext
 */
package org.openstoryboards.jsonschemadsl.generator

import java.util.LinkedList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.BasicType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.Constraint
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.DictionaryType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.EnumDefinition
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.IntegerType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.InterfaceDefinition
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.ListType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.NullableType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.NumberType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.ParenthesizedType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.ReferencedType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.RegexConstraint
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.StringType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.TranslationUnit
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.TupleType
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.Type
import org.openstoryboards.jsonschemadsl.jsonSchemaDsl.TypeDefinition

class JsonSchemaDslGenerator implements IGenerator {
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for(tu: resource.allContents.toIterable.filter(TranslationUnit)) {
			fsa.generateFile("out.coffee", tu.compile)
		}
	}
 
	def compile(TranslationUnit unit) '''
	class RegexConstraint
		constructor: (@regex) ->

	class IntervalConstraint
		constructor: (@openLeft, @openRight, @from, @to) ->
		test: (value) =>
			#if(@sizeConstraint?)
			#	if(@sizeConstraint.openLeft)
			#		if(@sizeConstraint.left?) #TODO
			true		

	class Type
		validate: (object) =>
			throw new Error("Not implemented validator!")

	#basic types
	class BooleanType extends Type
		validate: (object) =>
			typeof(object) === "boolean"

	class AnyType extends Type
		validate: (object) =>
			true

	class NullType extends Type
		validate: (object) =>
			object === null
	
	class EnumerationType extends Type
		maxValue: 0
		constructor: (values) ->
			index = 0
			maxValue = values.length
			for value in values
				this[value] = index++
		validate: (object)
			typeof(object) == "number" && Math.floor(object) == object && object < maxValue

	class NumberType extends Type
		constructor: (@constraint) ->
		validate: (object) =>
			typeof(object) == "number" && (!(@constraint?) || @constraint.test(object))

	class IntegerType extends NumberType
		constructor: (constraint) -> 
			super(constraint)
		validate: (object) =>
			super(object) && Math.floor(object) == object

	class StringType extends Type
		constructor: (@sizeConstraint, @regexConstraint) ->
		validate: (object) =>
			if(typeof(object) !== "string")
				return false
			if(@regexConstraint?)
				if(!@regexConstraint.regex.test(object))
					return false
			(!(@sizeConstraint?) || @sizeConstraint.test(object.length))

	#composite types
	class NullableType extends Type
		constructor: (@type) ->
		validate: (object) =>
			object == null || @type.validate(object)

	class DictionaryType extends Type
		constructor: (@keyType, @valueType, @sizeConstraint) ->
		validate: (object) =>
			if(typeof(object)!="object")
				return false
			size = 0
			for key, value of object
				size++
				if(!@keyType.validate(key))
					return false
				if(!valueType.validate(value))
					return false
			(!(@sizeConstraint?) || @sizeConstraint.test(size))

	class ListType extends Type
		constructor: (@elementType, @sizeConstraint) ->
		validate: (object) =>
			if(!Array.isArray(object))
				return false
			for value in object
				if(!elementType.validate(value))
					return false
			(!(@sizeConstraint?) || @sizeConstraint.test(object.length))

	class TupleType extends Type
		constructor: (@tupleTypes) ->
		validate: (object) =>
			if(!Array.isArray(object))
				return false
			if(@tupleTypes.length != object.length)
				return false
			index = 0
			for tupleType in @tupleTypes
				value = object[index++]
				if(!tupleType.validate(value))
					return false
			true

	class StructType extends Type		
		constructor: (@name, @isAbstract, @superType, @members) ->
		validate: (object, isSubClass) =>
			if(typeof(object) !== "object")
				return false
			if(typeof(isSubClass) == "boolean" && isSubClass)
				if(@isAbstract)
					return false
			else
				if(object["$type"] !== @name)
					return false
			if(@superType? && !@superType.validate(object, true))
				return false
			for name, type of @members
				if(!object[name]?)
					return false
				if(type.validate(object[name]))
					return false
			true

	class ProxyType extends Type
		constructor: -> @type = null
		setType: (@type) =>
		validate: (object) =>
			if(@type === null)
				throw new Error("No type assigned to proxy!")
			@type.validate(object)

	types = {}
	
	#enumerations
	«FOR enumDefinition: unit.definitions.filter(EnumDefinition)»
	types.«enumDefinition.name» = new EnumerationType([«enumDefinition.literals.map[lit | "\""+lit.name+"\""].join(", ")»])
	«ENDFOR»
	
	#proxies
	«FOR definition: unit.definitions.filter[d | !(d instanceof EnumDefinition || d instanceof InterfaceDefinition)]»
	types.«definition.name» = new ProxyType()
	«ENDFOR»
	
	#typedefs
	«FOR definition: unit.definitions.filter(TypeDefinition)»
	types.«definition.name».setType(«definition.type.compile»)
	«ENDFOR»
	
	#structs
	
	#interfaces
	
	module.exports = types
	'''
	
	def compile(Constraint constraint) {
		if(constraint == null)
			return "null"
		val openLeft = constraint.left.bracket.equals("(")
		val openRight = constraint.right.bracket.equals(")")
		val from = if(constraint.from != null) constraint.from.value else null
		val to = if(constraint.to != null) constraint.to.value else null
		'''new IntervalConstraint(«openLeft», «openRight», «from», «to»)'''
	}
	def compile(RegexConstraint constraint) {
		if(constraint == null)
			return "null"
		'''new RegexConstraint(«constraint.pattern»)'''
	}
	
	def String compile(Type type) {
		switch(type) {
			//basic types
			BasicType:
				switch((type as BasicType).name) {
					case "boolean": '''new BooleanType()'''
					case "any": '''new AnyType()'''
					case "null": '''new NullType()'''
				}
			IntegerType: '''new IntegerType(«(type as IntegerType).constraint.compile»)'''
			NumberType: '''new NumberType(«(type as NumberType).constraint.compile»)'''
			StringType: '''new StringType(«(type as StringType).constraint.compile», «(type as StringType).regexConstraint.compile»)'''
			
			//composite types
			NullableType: '''new NullableType(«(type as NullableType).type.compile»)'''
			DictionaryType: {
				val dictionary = type as DictionaryType 
				val key = dictionary.keyType.compile
				val value = dictionary.valueType.compile
				val constraint = dictionary.constraint.compile
				'''new DictionaryType(«key», «value», «constraint»)'''
			}
			ListType: {
				val list = type as ListType 
				val element = list.elementType.compile
				val constraint = list.constraint.compile
				'''new ListType(«element», «constraint»)'''
			}
			TupleType: {
				val tuple = type as TupleType 
				val list = new LinkedList<String>()
				for(Type tupleType : tuple.types)
					list.add(tupleType.compile)
				'''new TupleType([«list.join(",")»])'''
			}
			
			ParenthesizedType: (type as ParenthesizedType).type.compile
			ReferencedType: '''types.«(type as ReferencedType).name»'''
		}	
	}
}
